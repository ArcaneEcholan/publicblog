---
title: Maven: invalid target release？
date: '2025-04-21'
tags: ['java', 'maven']
draft: false
summary:
---

## 起因

如果 Maven 使用 jdk8，并通过以下插件编译，大概率会得到  `invalid target release: 11`

```xml
<build>
  <plugins>
    <plugin>
      <artifactId>maven-compiler-plugin</artifactId>
      <version>3.10.1</version>
      <configuration>
        <source>11</source>
        <target>11</target>
      </configuration>
    </plugin>
  </plugins>
</build>
```

这个错误笔者遇到过不止一次了。

其实这个错误跟 maven 及其插件无关，因为即使只使用 javac 命令编译，也可能复现这个错误。

```shell
$ javac -version

javac 1.8.0_432

$ javac -target 11 HelloWorld.java

javac: invalid target release: 11
Usage: javac <options> <source files>
use -help for a list of possible options
```

如果使用 javac 11，再指定 -target 11，则不会出现该报错。

此时，你甚至可以指定 -target 8，只要没有使用超过 java8 的语法，编译仍然能通过。


要看下 javac 说明了。

```
$ man javac

...
       --target release or -target release
              Generates class files suitable for the  specified  Java  SE
              release.   The  supported values of release are the current
              Java SE release and a limited number of previous  releases,
              detailed in the command-line help.
...
```

这下知道了，一个版本的 javac 可以支持低于该版本的 java 语法的编译。

比如，javac 17 支持以 java17， java11， java8 ... 对源代码进行编译。
比如，javac 11 支持以 java11， java8 ... 对源代码进行编译。
比如，javac 8 支持以 java8 ... 对源代码进行编译。

而如果使用 javac 8 以 java11 的目标去编译，则会出现 `invalid target release: 11` 报错。







最近想搞清楚一件事：

> 当我们敲 `mvn compile` 的时候，它背后到底是用哪个 `javac` 在编译？

查了一堆资料，要么一笔带过，要么说得模糊。
干脆自己翻源码、动手实测，顺手把结论也记下来。

## 如果你只想要答案

- Maven 默认用的是**启动它那个 JVM 里的 javac**。
- 控制方法？**启动 Maven 前把 JAVA_HOME 设好就行**。
- 需要更细粒度控制？**fork + executable 配置 Maven 用指定的 javac**。

行了，想直接上手的到这里就够了。
后面是详细过程和坑点记录，想深入了解的话继续往下。

---

## 探索过程

### 1. Maven-Compiler-Plugin 是怎么找编译器的？

先翻源码：
[AbstractCompilerMojo.java#L1070](https://github.com/apache/maven-compiler-plugin/blob/7d44073616fcf93eb0c5f4aa43c3511da695a778/src/main/java/org/apache/maven/plugin/compiler/AbstractCompilerMojo.java#L1070)

```java
if (compilerId == null) {
    compilerId = DEFAULT_EXECUTABLE;
    final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
    if (compiler != null) {
        return compiler;
    }
}
```

很简单：
- 如果没特别配置，Maven 调 `ToolProvider.getSystemJavaCompiler()`。
- 这个玩意返回的是**当前 JVM 里内置的 javac**，准确点说是 `jdk.compiler` 模块里的 `com.sun.tools.javac.api.JavacTool`。

官方注释也明说了：

> Returns the Java programming language compiler provided with this platform.

总结一下就是——
**Maven 默认是用它自己跑着的 JVM 里自带的 javac。**

---

### 2. 那 Maven 启动时用的 JVM 又是哪个？

翻 Maven 的启动脚本：`your_maven_root/bin/mvn`。

```sh
if [ -z "$JAVA_HOME" ]; then
  JAVACMD="`command -v java`"
else
  JAVACMD="$JAVA_HOME/bin/java"
fi

exec "$JAVACMD" ...
```

读一遍就明白了：
- 如果你设了 `JAVA_HOME`，Maven 就用 `$JAVA_HOME/bin/java`
- 没设的话，它用系统默认 `java` 命令（通常是 `/usr/bin/java` 这样的）

所以想控制 Maven 用哪个 JDK？
**搞定 JAVA_HOME 就一切搞定。**

---

### 3. 来实测一下

#### 场景设定

我的 pom.xml 写了：

```xml
<build>
  <plugins>
    <plugin>
      <artifactId>maven-compiler-plugin</artifactId>
      <version>3.10.1</version>
      <configuration>
        <source>11</source>
        <target>11</target>
      </configuration>
    </plugin>
  </plugins>
</build>
```

要求是用 Java 11 编译。

#### 测试1：故意用 Java 8

```bash
export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64
mvn clean compile -X > logs__build
```

编译直接炸：

```
invalid target release: 11
```

> 证明 Maven 真的是拿 Java 8 的 `javac` 来编译，当然会挂。

#### 测试2：换回 Java 11

```bash
export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64
mvn clean compile -X > logs__build
```

干干净净通过。

---

### 4. 如果想更精准控制 javac 呢？

比如你不想改全局 `JAVA_HOME`，只想让 Maven 临时用一个特定 javac，可以这样搞：

pom.xml 里加配置：

```xml
<build>
  <plugins>
    <plugin>
      <artifactId>maven-compiler-plugin</artifactId>
      <version>3.10.1</version>
      <configuration>
        <source>11</source>
        <target>11</target>
        <fork>true</fork>
        <executable>/usr/lib/jvm/java-11-openjdk-amd64/bin/javac</executable>
      </configuration>
    </plugin>
  </plugins>
</build>
```

源码对应位置：
[AbstractCompilerMojo.java#L1052](https://github.com/apache/maven-compiler-plugin/blob/7d44073616fcf93eb0c5f4aa43c3511da695a778/src/main/java/org/apache/maven/plugin/compiler/AbstractCompilerMojo.java#L1052)

```java
if (fork) {
    if (executable == null) {
        executable = DEFAULT_EXECUTABLE;
    }
    return new ForkedCompiler(this);
}
```

总结：
- `fork=true`，Maven 开子进程去跑 javac
- `executable` 明确告诉它用哪个 javac

这么搞完全不用动环境变量，干净利落。

---

## 最后小结

一句话总结：

> Maven 默认用的是它跑起来的 JVM 里的 javac，要想控制它，用 JAVA_HOME 或 fork+executable。

---

## 后续想做的

- 研究一下 Maven Toolchains 的用法，感觉可以更优雅地切换多套 JDK，懒得每次 export。
- 顺便看看多 JDK 项目怎么统一配置编译环境。

---

# end.
