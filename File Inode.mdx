---
title: "File Inode"
date: '2025-07-03'
tags: ['filesystem', 'linux']
draft: false
summary:
---

# 前言

不关闭文件（fd，或者文件流）会导致文件 inode 不被释放，在用temp文件利用磁盘空间的时候，这尤为可能成为很大的问题。因为一堆没有关闭的流或者fd可能在进程或者的时候在磁盘上造成一堆幽灵空间。（delete但是inode仍然存在的inode）

inode 可能被 dirent 和 open file table entry 引用，只有二者的引用计数都归零之后，文件inode才得以删除。

接下来的时间，交给 gpt，开始它的表演（我没审查内容）。

# 理解 Linux 中文件访问的核心机制：fd、open file、inode 与数据块全景图

在日常 Java/C/Linux 编程中，你可能遇到过如下现象：

-   文件已经 `delete()`，但 `df` 显示磁盘空间没释放；

-   使用 `dup()` 后写入的数据顺序不对；

-   多进程访问同一个文件，数据错乱；


这些都指向了 Linux 文件系统底层结构的一个核心事实：**你操作的文件并不是一个简单的句柄，而是一套复杂的三层结构在协同工作。**

本文尝试从底层结构出发，把这些核心概念讲清楚：

---

## 一、完整结构图：进程到磁盘的五层关系

```text
[用户空间]
+-------------------------------+
|         进程 (PID)            |
+-------------------------------+
| 文件描述符表 (FD table)       |   ← 每个进程私有
|  fd 0 → open file entry [X]   |
|  fd 1 → open file entry [Y]   |
+-------------------------------+
            |             |
            v             v
      +-----------------------------+
      |     Open File Table         |  ← 内核全局共享
      |  entry X: offset, flags, → inode I1
      |  entry Y: offset, flags, → inode I2
      +-----------------------------+
                        |
                        v
                +------------------+
                |     inode (I1)   | ← 文件元数据（不含路径）
                +------------------+
                        |
                        v
               +--------+---------+
               |  data block(s)   | ← 实际文件内容
               +------------------+

        ↑
        |
+----------------------------+
|     dirent（目录项）       | ← 路径名映射 inode（link/unlink 的目标）
| "/tmp/foo.txt" → inode I1 |
+----------------------------+
```

---

## 二、关键结构概念简述

| 结构 | 说明 |
| --- | --- |
| **fd** | 用户进程视角的文件句柄，是一个索引值（整数） |
| **open file entry** | 内核的打开状态，记录 offset、flags、inode 指针 |
| **inode** | 文件本体的元数据，不包含路径名 |
| **data block** | 文件内容的物理存储 |
| **dirent** | 目录项，路径名映射到 inode，`link`/`unlink` 操的就是它 |

---

## 三、为什么需要 fd？为什么不直接暴露 open file entry？

很多人疑问：既然 open file entry 记录了 offset、flags，干嘛还要 fd 这一层？直接给用户用不是更简单？

**答案：fd 是设计上的隔离、抽象、安全机制。**

### ✅ 设计意义：

| fd 带来的能力 | 说明 |
| --- | --- |
| **安全隔离** | 每个进程的 fd 表私有，无法直接影响其他进程 |
| **资源抽象** | 所有 I/O 资源（文件/socket/pipe/device）统一变成 fd |
| **共享语义** | 多个 fd → 同一个 open file entry（如 `dup()`） |
| **多态语义** | 多个 fd → 不同 entry → 同一个 inode（如两次 `open()`） |
| **系统调用简化** | 所有接口都是 `read(fd, ...)` 风格，用户只操 fd，内核做映射 |

---

## 四、unlink 和 link 操作的是什么？

它们**不涉及 fd，也不涉及 open file entry**，而是操作 **目录项 dirent**：

```text
路径名 "/tmp/a.txt" → dirent → inode 1234
```

### ✅ 操作行为：

| 操作 | 意义 |
| --- | --- |
| `unlink(path)` | 删除一个路径 → inode link count -1 |
| `link(old, new)` | 增加一个路径 → inode link count +1 |

inode 只有在：

```text
link count == 0 && open count == 0
```

时才被彻底释放（即 inode + data block 真正回收）

---

## 五、dup() 共享偏移和 flags 的实际意义

### ✅ 示例代码：共享偏移

```c
int fd1 = open("log.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
int fd2 = dup(fd1);

write(fd1, "abc", 3);  // offset 变成 3
write(fd2, "XYZ", 3);  // offset 从 3 接着写
```

📄 输出：`abcXYZ`

→ `fd1` 和 `fd2` 共享一个 open file entry，因此写偏移是连续的。

---

### ✅ 示例代码：共享 flags（如 O\_APPEND）

```c
int fd1 = open("log.txt", O_WRONLY | O_APPEND);
int fd2 = dup(fd1);

lseek(fd2, 0, SEEK_SET);
write(fd2, "AAA", 3);  // 仍然追加到文件末尾
```

→ `dup` 复制的是“访问状态”，即 open file entry 指针，不是 inode 或文件副本。

---

## 六、总结对照表

| 层级 | 数据结构 | 属于谁 | 作用 |
| --- | --- | --- | --- |
| 应用层 | `fd` | 每进程私有 | 映射到 open file entry，系统调用入口 |
| 内核层 | open file entry | 全局共享 | 持有 offset、flags、inode 指针 |
| 文件系统层 | `inode` | 全系统唯一 | 文件元信息、指向数据块 |
| 存储层 | data block | 块设备 | 实际存放内容 |
| 文件名层 | dirent（目录项） | 每目录存在 | 名称 → inode 映射关系，受 `link`/`unlink` 操作影响 |

---

# lsof deleted 标识

man lsof

```
lsof - list open files
```

##  一、Linux 文件系统三层概念

在内核视角，一个“文件”其实包含三个层次：

| 层 | 名称 | 说明 |
| --- | --- | --- |
| 1️⃣ | **fd（File Descriptor）** | 进程打开文件后获得的“句柄编号”，在 `/proc/<pid>/fd/` 下能看到 |
| 2️⃣ | **inode（索引节点）** | 存储文件的实际数据块和元信息（权限、大小、时间等） |
| 3️⃣ | **dirent（directory entry）** | 目录项：文件名到 inode 的映射（名字→内容） |

可以理解为：

```
文件名（dirent） --> inode（文件内容） <-- fd（进程打开的引用）
```

* * *

##  二、几个关键操作的区别

| 操作 | 影响 fd | 影响 dirent | 说明 |
| --- | --- | --- | --- |
| `rm file` | ❌ 不影响现有 fd | ✅ 删除目录项（dirent） | 文件“名字”被移除；若仍有进程打开（持有 fd），inode 仍存在；此时会显示 `(deleted)` |
| `File.delete()`（Java） | ❌ 不影响 fd（除非程序关闭） | ✅ 删除 dirent | 其实和 `rm` 一样，本质是调用 `unlink()` 系统调用 |
| `fileinputstream.close()`（Java） | ✅ 关闭 fd | ❌ 不动 dirent | 只是告诉内核“我不再使用这个文件”；如果文件名还在，就仍存在于目录中 |
| `open()` | ✅ 新建 fd | ❌ 不动 dirent | 打开一个文件，进程引用 inode |
| `unlink()` | ❌ | ✅ 删除目录项 | 核心删除动作，本质上 `rm` 调的就是它 |

* * *

##  三、为什么会出现 `(deleted)`

出现 `(deleted)` 的根本原因：

> **文件的 dirent 被删除（unlink），但仍有进程持有对应的 fd 引用到该 inode。**

因此：

* 文件对普通用户不可见（ls 看不到）

* 但文件内容仍在磁盘中（inode 和数据块仍存在）

* `/proc/<pid>/fd` 里还能看到文件路径后缀 `(deleted)`

* `lsof` 输出中就会显示：

    ```
    dockerd  1789  ...  /var/log/rsyslog.stderr.log (deleted)
    ```


* * *

##  举个直观例子：

```bash
# 启动一个进程打开文件
$ tail -f /var/log/syslog &
[1] 1234

# 删除文件
$ rm /var/log/syslog
$ ls /var/log/syslog
ls: cannot access '/var/log/syslog': No such file or directory

# 但查看打开的文件
$ sudo lsof | grep syslog
tail    1234  user  3r  REG  8,1  123456 /var/log/syslog (deleted)
```

此时：

* `rm` 删除了目录项（dirent）

* 进程 `tail` 仍持有文件描述符（fd）

* 所以文件仍在占用空间，显示 `(deleted)`


* * *

##  四、什么时候空间真正释放？

当且仅当：

* 所有进程都关闭了该文件（`close(fd)`），
    **且**

* 没有任何目录项指向该 inode（`unlink()` 过）


此时内核引用计数为 0，inode 才会被回收，磁盘空间真正释放。

* * *

##  总结成一句表格：

| 操作 | 是否操作 fd | 是否操作 dirent | 是否导致 `(deleted)` |
| --- | --- | --- | --- |
| `rm file` | ❌ | ✅ 是 | ✅ 若仍被进程打开 |
| `File.delete()` | ❌ | ✅ 是 | ✅ 若仍被进程打开 |
| `fileinputstream.close()` | ✅ 是 | ❌ 否 | ❌ |
| 程序退出 | ✅（系统关闭全部 fd） | ❌ 否 | ❌（inode 回收） |

* * *

##  最后一句话总结：

> `(deleted)` 文件的本质是：
> 文件“名字”没了（dirent 被删），
> 但“内容”还活着（inode 仍被某个 fd 引用）。
