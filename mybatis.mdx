---
title: 'mybatis'
date: '2025-09-21'
tags: ['java']
draft: false
summary:
---

## Mybatisplus 增强后的 basemapper

普通 MyBatis 是怎么做的？

写一个接口：

```
@Mapper
public interface UserMapper {
    User selectById(Long id);
}
```

MyBatis 会在启动时解析对应的 UserMapper.xml，把 `<select id="selectById">` 里的 SQL 绑定到这个接口的方法。

执行时，通过 Mapper 动态代理 (MapperProxy) 拦截方法调用，找到 MappedStatement，然后交给 Executor → JDBC 执行。

核心点：必须写 XML（或者注解 @Select 等）。

**plus 增强**

MyBatis-Plus 的目标是 让你不用写 XML 也能执行常见的 CRUD。
所以它提供了一个 `BaseMapper<T>` 接口，里面定义了一堆通用方法：
```
public interface BaseMapper<T> {
    T selectById(Serializable id);
    int insert(T entity);
    int updateById(T entity);
    int deleteById(Serializable id);
    // ...
}
```

你自己的 Mapper 只需要继承它：

```
@Mapper
public interface UserMapper extends BaseMapper<User> {
}
```

然后，你就能直接写：

`userMapper.selectById(1L);`

## Mybatis 核心逻辑

### 流程

假设是： `usermapper.querybyname(String name)` 自定义mapper方法，

可以debug MybatisMapperMethod.execute(), 完了是 executeForMany，进去做两件事儿：
* mapper方法参数转成合适的类型（比如map，mybatis往里面放点儿私活,param1,param2什么的）
* sqlsession.selectlist 代理接下来的流程。

DefaultSqlSession.selectList

```
    MappedStatement ms = configuration.getMappedStatement(statement);
    return executor.query(ms, wrapCollection(param), RowBounds.DEFAULT, Executor.NO_RESULT_HANDLER);
```

第一件事儿就是拿到 ms（mappedstatement），这个东西是 mybatis 里对每条 sql 语句的抽象，里面有 sql id，sql文本，sql类型（select,update,insert,delete），参数类型，返回值类型，resultmap等信息。说白了就是一个 app 启动之后解析的每条 xml 语句和 mapper 注解语句生成的一个带有占位符信息的sql模板。 configuration.getMappedStatement(statement); 这个里边儿可以看到一溜这样的模板, xml, mapper接口的注解，程序启动就解析好了，执行的时候直接用，这些生成 mappedstatements 列表，

executor 接管之后就是，可得参数： ms + params。

ms 包含sql信息，params 是入参，最终目的是渲染sql，说白了就是创造 preparedstatement 然后把参数设置了。

preparedstatement 靠 statementhandler 生成，然后 它再委托 parameterhandler 设置参数。

之后就是执行了。

上述过程中有很多插件点，没时间梳理。

### 关注接口：

https://mybatis.org/mybatis-3/configuration.html#plugins

MyBatis allows you to intercept calls to at certain points within the execution of a mapped statement. By default, MyBatis allows plug-ins to intercept method calls of:

* Executor  (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)
* ParameterHandler (getParameterObject, setParameters)
* ResultSetHandler (handleResultSets, handleOutputParameters)
* StatementHandler (prepare, parameterize, batch, update, query)

重点关注 executor 的参数。（ms + params）

用拦截器去观察他们。mybatis plus 自带的的拦截器默认就会拦截他们，可以好好观察一下，什么情况，params 长啥样。对定制很有帮助。

### debug

两条路：wrappers + mappers.

如参绑定中的typehandler：debug路径推荐：拦截executor api

```
intercept(){

    interceptor.beforequery

    simpleexecutor::doquery

    simpleexecutor.prepareStatement

    handler.parameterize(stmt)

    ##execotor.query

    返回值绑定： DefaultResultSetHandler.getPropertyMappingValue#typeHandler.getResult(rs, column)


    interceptor.afterquery

}
```

**原理**: 每条mapper语句都会编程一条boundsql对象，其中记录了绑定到param或者实体字段的typehandler。setParameters 阶段会调用这些typehandler。

## typehandler 绑定：

* 实体字段： `@TableField(typeHandler = XxxTypeHandler.class)`. 这种方法只要确保用的是一个实体类，走的是insert(entity) 或者 selectbyid（entity）之类封装好的mapper方法，basemapper里面会自动解析。声明益处出出生效。
* mapper：这种分为一下两种具体方式，需要在用到的地方都显示声明typehandler，无论是入参还是返回值。
* mapper参数（或者返回只）：
```
    // 这个可以用注解的方式定义，这里不写了比较麻烦
    <resultMap id="PatientInfoMap" type="com.example.projects__springportable.PatientInformationDto">
        <id property="id" column="id"/>
        <result property="name" column="name" typeHandler="com.example.projects__springportable.AesEncryptHandler"/>
<!--        <result property="phone" column="phone" typeHandler="com.example.projects__springportable.AesEncryptHandler"/>-->
<!--        <result property="address" column="address" typeHandler="com.example.projects__springportable.AesEncryptHandler"/>-->
        <!-- 其他不需要加密的字段照常映射 -->
    </resultMap>
    @Select("SELECT * FROM patient WHERE name = #{name, typeHandler=com.example.projects__springportable.AesEncryptHandler}")
    @ResultMap("PatientInfoMap")
    List<PatientInformationDto> getByName(@Param("name") String name);
```
* mapperxml:
```xml
    <resultMap id="PatientInfoMap" type="com.example.projects__springportable.PatientInformationDto">
        <id property="id" column="id"/>
        <result property="name" column="name" typeHandler="com.example.projects__springportable.AesEncryptHandler"/>
<!--        <result property="phone" column="phone" typeHandler="com.example.projects__springportable.AesEncryptHandler"/>-->
<!--        <result property="address" column="address" typeHandler="com.example.projects__springportable.AesEncryptHandler"/>-->
        <!-- 其他不需要加密的字段照常映射 -->
    </resultMap>
    <select id="getByName" resultMap="PatientInfoMap">
        SELECT * FROM patient WHERE name = #{name, typeHandler=com.example.projects__springportable.AesEncryptHandler}
    </select>
```

# boundsql

### 🔹 `BoundSql` 的定义

`org.apache.ibatis.mapping.BoundSql`
里面主要有这几个关键内容：

1. **sql**

    * 最终要交给 JDBC 执行的 SQL 语句（包含 `?` 占位符）。

    * 比如你写的：

        ```xml
        <select id="findUser" parameterType="int" resultType="User">
          select * from user where id = #{id}
        </select>
        ```

        * 在 `BoundSql` 里会变成：

            ```sql
            select * from user where id = ?
            ```

2. **parameterObject**

    * 传入的参数对象（比如 `id=123`）。

3. **parameterMappings**

    * 记录了每个 `?` 对应的参数信息（名称、JDBC 类型、处理器）。

    * 比如上面的 SQL 就会有一个 `ParameterMapping("id", Integer.class)`。

4. **additionalParameters**

    * 附加参数，比如动态 SQL（`<foreach>`、`<bind>`）产生的临时变量。


* * *

### 🔹 作用

可以理解为：

* **MappedStatement** → SQL 模板（带 `#{}` 占位符）。

* **BoundSql** → 绑定参数之后的 SQL（带 `?` 占位符，参数映射信息都在里面）。


所以 MyBatis 执行 SQL 的流程大概是：

1. 根据 `MappedStatement` 和参数对象生成 `BoundSql`。

2. `StatementHandler` 用 `BoundSql` 里的 SQL + 参数映射，设置到 `PreparedStatement`。

3. JDBC 执行 SQL。


* * *

### 🔹 举个例子

假设你调用：

```java
mapper.findUser(123);
```

* `MappedStatement`：

    ```sql
    select * from user where id = #{id}
    ```

* `BoundSql`：

    * sql:

        ```sql
        select * from user where id = ?
        ```

    * parameterObject: `123`

    * parameterMappings: `[id → Integer]`


最终 JDBC 执行的是：

```sql
select * from user where id = 123;
```
